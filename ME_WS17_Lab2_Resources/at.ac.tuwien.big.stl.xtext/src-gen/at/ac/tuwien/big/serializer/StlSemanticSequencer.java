/*
 * generated by Xtext 2.12.0
 */
package at.ac.tuwien.big.serializer;

import at.ac.tuwien.big.services.StlGrammarAccess;
import at.ac.tuwien.big.stl.Area;
import at.ac.tuwien.big.stl.Buffer;
import at.ac.tuwien.big.stl.Connector;
import at.ac.tuwien.big.stl.Conveyor;
import at.ac.tuwien.big.stl.ItemGenerator;
import at.ac.tuwien.big.stl.ItemType;
import at.ac.tuwien.big.stl.Machine;
import at.ac.tuwien.big.stl.ProductStore;
import at.ac.tuwien.big.stl.STLPackage;
import at.ac.tuwien.big.stl.Service;
import at.ac.tuwien.big.stl.Slot;
import at.ac.tuwien.big.stl.TurnTable;
import at.ac.tuwien.big.stl.WasteStore;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class StlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private StlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == STLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case STLPackage.AREA:
				sequence_Area(context, (Area) semanticObject); 
				return; 
			case STLPackage.BUFFER:
				sequence_Buffer(context, (Buffer) semanticObject); 
				return; 
			case STLPackage.CONNECTOR:
				sequence_Connector(context, (Connector) semanticObject); 
				return; 
			case STLPackage.CONVEYOR:
				sequence_Conveyor(context, (Conveyor) semanticObject); 
				return; 
			case STLPackage.ITEM_GENERATOR:
				sequence_ItemGenerator(context, (ItemGenerator) semanticObject); 
				return; 
			case STLPackage.ITEM_TYPE:
				sequence_ItemType(context, (ItemType) semanticObject); 
				return; 
			case STLPackage.MACHINE:
				sequence_Machine(context, (Machine) semanticObject); 
				return; 
			case STLPackage.PARAMETER:
				sequence_Parameter(context, (at.ac.tuwien.big.stl.Parameter) semanticObject); 
				return; 
			case STLPackage.PRODUCT_STORE:
				if (rule == grammarAccess.getProductStoreRule()) {
					sequence_ProductStore(context, (ProductStore) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNamedElementRule()
						|| rule == grammarAccess.getComponentRule()
						|| rule == grammarAccess.getStoreRule()) {
					sequence_ProductStore_Store(context, (ProductStore) semanticObject); 
					return; 
				}
				else break;
			case STLPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case STLPackage.SLOT:
				sequence_Slot(context, (Slot) semanticObject); 
				return; 
			case STLPackage.SYSTEM:
				sequence_System(context, (at.ac.tuwien.big.stl.System) semanticObject); 
				return; 
			case STLPackage.TURN_TABLE:
				if (rule == grammarAccess.getNamedElementRule()
						|| rule == grammarAccess.getComponentRule()) {
					sequence_Component_TurnTable(context, (TurnTable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTurnTableRule()) {
					sequence_TurnTable(context, (TurnTable) semanticObject); 
					return; 
				}
				else break;
			case STLPackage.WASTE_STORE:
				sequence_WasteStore(context, (WasteStore) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     NamedElement returns Area
	 *     Area returns Area
	 *
	 * Constraint:
	 *     (name=ID components+=Component* connectors+=Connector*)
	 */
	protected void sequence_Area(ISerializationContext context, Area semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Buffer
	 *     Component returns Buffer
	 *     Buffer returns Buffer
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Buffer(ISerializationContext context, Buffer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBufferAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns TurnTable
	 *     Component returns TurnTable
	 *
	 * Constraint:
	 *     (name=ID cost=EInt services+=Service* inputSlots+=Slot* outputSlots+=Slot*)
	 */
	protected void sequence_Component_TurnTable(ISerializationContext context, TurnTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Connector returns Connector
	 *
	 * Constraint:
	 *     (entry=[Slot|ID] exit=[Slot|ID])
	 */
	protected void sequence_Connector(ISerializationContext context, Connector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.CONNECTOR__ENTRY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.CONNECTOR__ENTRY));
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.CONNECTOR__EXIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.CONNECTOR__EXIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectorAccess().getEntrySlotIDTerminalRuleCall_1_0_1(), semanticObject.eGet(STLPackage.Literals.CONNECTOR__ENTRY, false));
		feeder.accept(grammarAccess.getConnectorAccess().getExitSlotIDTerminalRuleCall_3_0_1(), semanticObject.eGet(STLPackage.Literals.CONNECTOR__EXIT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Conveyor
	 *     Component returns Conveyor
	 *     Conveyor returns Conveyor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Conveyor(ISerializationContext context, Conveyor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConveyorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ItemGenerator
	 *     Component returns ItemGenerator
	 *     ItemGenerator returns ItemGenerator
	 *
	 * Constraint:
	 *     (name=ID generatedType=[ItemType|ID]?)
	 */
	protected void sequence_ItemGenerator(ISerializationContext context, ItemGenerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ItemType
	 *     ItemType returns ItemType
	 *
	 * Constraint:
	 *     (name=ID description=EString)
	 */
	protected void sequence_ItemType(ISerializationContext context, ItemType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.ITEM_TYPE__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.ITEM_TYPE__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getItemTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getItemTypeAccess().getDescriptionEStringParserRuleCall_3_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Machine
	 *     Component returns Machine
	 *     Machine returns Machine
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Machine(ISerializationContext context, Machine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMachineAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(ISerializationContext context, at.ac.tuwien.big.stl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProductStore returns ProductStore
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProductStore(ISerializationContext context, ProductStore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProductStoreAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ProductStore
	 *     Component returns ProductStore
	 *     Store returns ProductStore
	 *
	 * Constraint:
	 *     (name=ID capacity=EInt)
	 */
	protected void sequence_ProductStore_Store(ISerializationContext context, ProductStore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.STORE__CAPACITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.STORE__CAPACITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProductStoreAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStoreAccess().getCapacityEIntParserRuleCall_1_1_0(), semanticObject.getCapacity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Service
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=ID cost=EInt processingTime=EInt reliability=EDouble parameters+=Parameter*)
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slot returns Slot
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Slot(ISerializationContext context, Slot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSlotAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *     NamedElement returns System
	 *
	 * Constraint:
	 *     (name=ID itemTypes+=ItemType+ areas+=Area+)
	 */
	protected void sequence_System(ISerializationContext context, at.ac.tuwien.big.stl.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TurnTable returns TurnTable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_TurnTable(ISerializationContext context, TurnTable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTurnTableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns WasteStore
	 *     Component returns WasteStore
	 *     Store returns WasteStore
	 *     WasteStore returns WasteStore
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_WasteStore(ISerializationContext context, WasteStore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, STLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWasteStoreAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
